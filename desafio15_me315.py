# -*- coding: utf-8 -*-
"""desafio15_ME315.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15MAQsejLS_4bFkbe8nVd48NZ5WC9HDja

**Desafio 15**

Julia Folgueral - RA: 277178

Utilize Julia e apresente um exemplo de loops em paralelo (compare o tempo de processamento gasto se utilizar apenas em série).
"""

using Base.Threads

# Verificar se temos mais de uma thread disponível para realizar o loop em paralelo:
println("Threads: ", nthreads())

# Definir o número de repetições:
N = 1_000

# Criar uma função para multiplicar matrizes:
function matrix_task()
    A = rand(200, 200)
    B = rand(200, 200)
    return A * B
end


# Loop em SÉRIE:
function serie(N)
    s = 0.0
    for i in 1:N
        X = matrix_task()
        s += sum(X)
    end
    return s
end

# Loop em PARALELO:
function paralelo(N)
    partial = zeros(Float64, nthreads())
    @threads for i in 1:N
        X = matrix_task()
        partial[threadid()] += sum(X)
    end
    return sum(partial)
end

# Contar o tempo de cada loop:
println("\n--- Série ---")
@time serie(N)

println("\n--- Paralelo ---")
@time paralelo(N)

"""O loop em paralelo (usando 2 threads) deixou o processamento bem mais rápido do que o loop em série. Enquanto o código em série levou mais de 2,5 segundos, o paralelo terminou em menos de 1 segundo.

Isso acontece porque, com duas threads, o trabalho é dividido entre dois núcleos do computador, acelerando a tarefa. Assim, mesmo com poucas threads, o paralelismo já é mais vantajoso na velocidade.
"""